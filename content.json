[{"title":"MySQL锁机制实践","date":"2017-02-11T07:39:07.000Z","path":"2017/02/11/MySQL锁机制实践/","text":"最近几天项目上遇到一个需求，现有系统需要访问外部的API，而API提供方的鉴权方式 ，需要三个步骤：1.访问签名接口1获取授权编码（authCode），authCode有效期10s，authCode在生命周期内无法重复获取且只能使用一次；2.根据授权编码生成加密后的数字签名；3.根据授权编码、数字签名访问接口2获得令牌token，token有效期20分钟；业务接口访问带上token值完成鉴权认证，考虑到系统采用的是集群部署，无法在应用层面保证数据的一致性，为此考虑采用MySQL的锁机制进行实现，正好系统的学习一下MySQL的锁机制。 1、MySQL锁概述相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁，目前本系统采用到的存储引擎为InnoDB。 从锁的粒度层面MySQL分为表级锁、页面锁、行级锁三种形式。三种形式在系统开销、加锁速度、是否出现死锁、并发性能、锁的粒度都不太一样，如下表格所示： 锁类型 系统开销 加锁速度 死锁 并发性能 锁的粒度 表级锁 系统开销小 加锁快 不死锁 并发底 锁的粒度大 页面锁 两者之间 两者之间 会死锁 两者之间 两者之间 行级锁 系统开销大 加锁慢 会死锁 并发高 锁的粒度小 从上述特点可见，从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web查询类应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理系统。下面重点介绍MySQL基于InnoDB的锁机制。 2、InnoDB锁机制InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。行级锁与表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。下面我们先介绍一点背景知识，然后详细讨论InnoDB的锁问题。 2.1、事务的ACID属性 原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。 一致性：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。 隔离性：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。 持久性：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。2.2、应用并发带来的问题 数据丢失当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更新。举个栗子：两个线程同时更改某一行数据，线程1先读取某一行数据，此时线程2也同时读取了该行数数据，线程1对该数据的某一个字段进行+1的操作，线程2也对该字段进行+1的操作，数据库将保留最后一个线程的数据，如果能做到1个线程在修改数据且没有提交事务之前，另一个线程不能访问该数据，则可避免此问题。 读脏数据一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。 不可重复读一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。 幻读一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。2.3、InnoDB行锁争用情况通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：1234567891011mysql&gt; show status like 'innodb_row_lock%';+-------------------------------+-------+| Variable_name | Value |+-------------------------------+-------+| Innodb_row_lock_current_waits | 0 || Innodb_row_lock_time | 0 || Innodb_row_lock_time_avg | 0 || Innodb_row_lock_time_max | 0 || Innodb_row_lock_waits | 0 |+-------------------------------+-------+5 rows in set (0.00 sec) 还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。具体方法如下：1234mysql&gt; use mysql;Database changedmysql&gt; CREATE TABLE innodb_monitor(a INT) ENGINE=INNODB;Query OK, 0 rows affected (0.09 sec) 然后就可以用下面的语句来进行查看：12345678910111213mysql&gt; show innodb status\\G;*************************** 1. row ***************************Status:=====================================170211 13:46:24 INNODB MONITOR OUTPUT=====================================Per second averages calculated from the last 1 seconds----------SEMAPHORES----------OS WAIT ARRAY INFO: reservation count 3, signal count 3Mutex spin waits 0, rounds 20, OS waits 0RW-shared spins 6, OS waits 3; RW-excl spins 0, OS waits 0 监视器可以通过下列命令来停止查看：12mysql&gt; DROP TABLE innodb_monitor;Query OK, 0 rows affected (0.05 sec) 设置监视器后，在SHOW INNODB STATUS的显示内容中，会有详细的当前锁等待的信息，包括表名、锁类型、锁定记录的情况等，便于进行进一步的分析和问题的确定。打开监视器以后，默认情况下每15秒会向日志中记录监控的内容，如果长时间打开会导致.err文件变得非常的巨大，所以用户在确认问题原因之后，要记得删除监控表以关闭监视器，或者通过使用“–console”选项来启动服务器以关闭写日志文件。 2.4、InnoDB的两种锁形式创建测试用到的库表：1234567891011121314151617mysql&gt; create database lock_test;Query OK, 1 row affected (0.00 sec)mysql&gt; use lock_test;Database changedmysql&gt; create table user( -&gt; user_id int comment '用户id' primary key, -&gt; user_name varchar(30) comment '用户姓名', -&gt; phone_no varchar(20) comment '用户手机号码' -&gt; );Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into user(`user_id`,`user_name`,`phone_no`) values (1, 'javaer1', '13925038990');Query OK, 1 row affected (0.00 sec)mysql&gt; insert into user(`user_id`,`user_name`,`phone_no`) values (2, 'javaer2', '13316037190');Query OK, 1 row affected (0.00 sec) 1、共享锁： 1SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE; 用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。 session1 session2 不做任何操作 不做任何操作 等待锁 不做任何操作 不做任何操作 死锁退出 获得锁后，可以成功更新 不做任何操作 2、排他锁1SELECT * FROM table_name WHERE ... FOR UPDATE session1 session2 对user_id=1的记录添加排他锁 不做任何操作 不做任何操作 能够查询数据，但是不能加排他锁，否则会挂起等待 执行更新，并且做commit 不做任何操作 不做任何操作 获得锁，执行查询语句 注意事项：InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。 3、实际应用 1、将authCode、Token存储在数据库中，作为一行记录存储； 2、每次查询数据库时加上排他锁，如果过期再去调用接口重新获取； 3、简化后的部分代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public String getToken(String logId) &#123; logger.info(\"[xxx接口调用-刷新token值]刷新token值开始，logId=&#123;&#125;\", logId); String token = \"\"; DataSource ds = getJdbc().getDataSource(); PreparedStatement pst = null; ResultSet rs = null; Connection conn = null; String querySql = \"select t.*,TIMESTAMPDIFF(SECOND, '1970-01-01 00:00:00', t.TOKEN_EXPIRE_TIME) AS TOKEN_EXPIRE_TIME_SECOND, TIMESTAMPDIFF(SECOND, '1970-01-01 00:00:00', now()) AS NOW_SECOND from xxx as t where t.ID='1' for update\"; try&#123; conn = ds.getConnection(); conn.setAutoCommit(false); pst = conn.prepareStatement(querySql); rs = pst.executeQuery(querySql); if(null != rs &amp;&amp; rs.next())&#123; //1.判断token是否过期 boolean isExpire = true; int tokenExpireTimeSecond = rs.getInt(\"TOKEN_EXPIRE_TIME_SECOND\"); int nowSecond = rs.getInt(\"NOW_SECOND\"); //2.token过期时间、当前时间 if((tokenExpireTimeSecond - nowSecond - 60) &gt; 0 )&#123; isExpire = false; token = rs.getString(\"TOKEN_DATA\"); return token; &#125; //TODO 3.获取authMap和tokenMap Map&lt;String,Object&gt; tokenMap = new HashMap&lt;String,Object&gt;(); Map&lt;String,Object&gt; authCodeMap = new HashMap&lt;String,Object&gt;(); token = (String)tokenMap.get(\"tokenData\"); if(isExpire)&#123; String updateSql = \"update xx set PUBLIC_KEY=? where ID = 1\"; pst = conn.prepareStatement(updateSql); pst.setString(1, CommonUtil.nullToString(authCodeMap.get(\"publicKey\"))); //PUBLIC_KEY pst.executeUpdate(); &#125; &#125;else&#123; //TODO 调用接口获取authCode和token数据信息，然后做新增插入操作 StringBuffer insertSql = new StringBuffer(\"insert into xxx (xx,xxx) values (?,?)\"); pst = conn.prepareStatement(insertSql.toString()); pst.setString(1, \"1\"); //ID pst.setString(2, \"xxx\"); //PUBLIC_KEY pst.executeUpdate(); &#125; conn.commit(); &#125;catch(Exception e)&#123; token = \"\"; try &#123; if(null != conn)&#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; logger.error(\"[xxx接口调用-刷新token值]出现异常，logId=&#123;&#125;，trace=\"+e, logId); &#125; finally&#123; try &#123; if(null != rs)&#123; rs.close(); &#125; if(null != pst)&#123; pst.close(); &#125; if(null != conn)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return token;&#125; 周末闲来无事，Mark一下，也算学习的笔记啦。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://javaer.site/tags/MySQL/"},{"name":"Java","slug":"Java","permalink":"http://javaer.site/tags/Java/"}]},{"title":"新年","date":"2017-01-27T09:22:25.000Z","path":"2017/01/27/新年/","text":"旧历的年底毕竟最像年底，村镇上不必说，就在天空中也显出将到新年的气象来。灰白色的沉重的晚云中间时时发出闪光，接着一声钝响，是送灶的爆竹；近处燃放的可就更强烈了，震耳的大音还没有息，空气里已经散满了幽微的火药香。《祝福》-鲁迅 93年前鲁镇过年场景大致也与我们这边的习俗也类似吧？！天空中烟花声、爆竹声此起彼伏，夹杂着远处、近处的回声，一层一层的萦绕在耳边。 爆竹声中一岁除，春风送暖入屠苏。是的，过完年也就意味着长了一岁，从年龄上来说自己真的老大不小了，但是就心理年龄而言，内心其实是个大男孩。只想说是沧桑忧愁了我的脸，人家其实才二十五，^_^。 喜欢简单，或者源于个性，或许出于经历。生活的劳累苦于心，心如间，需要我们进行删繁。这一年听的歌曲始终停留在民谣，最喜欢的歌手是汪晨蕊，不需要有太多的技巧，不需要有表现力多丰富的乐器，只是静静的弹着、唱着就能够让你内心产生一次一次的共鸣。真的，有些情绪是该说给懂的人听。 新的一年暗暗的给自己几个期许，因为有你们我会一直努力，因为有你们我将更加优秀。最后，祝大家在新的一年里步步高升，幸福美满。","tags":[{"name":"心情","slug":"心情","permalink":"http://javaer.site/tags/心情/"}]},{"title":"Hello World","date":"2017-01-23T12:58:04.000Z","path":"2017/01/23/hello-world/","text":"在Google君、Github君的帮助下，在完全闲下来的状态下，折腾了两天，我的个人博客终于搭建起来了。 整个博客系统基于Hexo，而Hexo则出自台湾大学生 tommy351 之手，是一个基于 Node.js的静态博客程序，其编译上百篇文字只需要几秒。Markdown写作，Hexo生成的静态页面推送到 Github 仓库，域名与 Github pages 绑定，这样一个逼格极高适合程序猿写作方式的博客就搭建完了。Hexo这个名字我很喜欢，就连发音都像是黑客哦！ 一直纠结是否需要自己搭建一个博客系统，之前一直在Wiz笔记上写技术博客，可是从2017年1月份开始，Wiz开始收费了，免费版无法与云端进行同步。看着自己账号下边的483篇文章，思来想去还是动手自己弄一个吧，况且之前用Wiz笔记的时候也非常熟悉 Markdown 的语法了，也特别想通过这种分享方式推动着自己不断进步。我更愿意把它作为我的一个小领地，在这里可以区别于QQ空间、微博、微信朋友圈式的分享，这里我可以完全按照自己的方式去分享心情、技术和曾经踩过的坑。 既然程序猿的世界数字永远从0开始，学习永远从 Hello World 开始，那么本篇博文就以 Hello Wolrd 为题吧。","tags":[{"name":"心情","slug":"心情","permalink":"http://javaer.site/tags/心情/"},{"name":"hexo","slug":"hexo","permalink":"http://javaer.site/tags/hexo/"}]}]