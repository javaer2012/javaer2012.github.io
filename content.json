[{"title":"一首清歌 几许烟雨","date":"2017-03-18T11:40:53.000Z","path":"2017/03/18/一首清歌-几许烟雨/","text":"细雨霏霏，寒意微微春天的雨总是那样如约而至忙了一整天，要回去的时候被缠绵的春雨给挡了回去最近，有些忙，有些惆怅就如同此刻的场景剪不断，理还乱 忙，在于事多、人少愁，在于招人、寻梦相信，在大家的努力下这些，都不是个事儿 近期，听了一首新歌叫《父亲写的散文诗》好久没有那么感动过由此，想起了自己的父亲已到花甲之年为了儿女还在各种操劳父爱如山愿父亲健康、快乐 一年回去2-3次家虽然熟悉，但也像是过客每当习惯时，转眼却得离开这些年，真的非常感谢姐姐、姐夫对父母的照顾都说2017年，我们铿锵前行相信一些都会变好大家都要好好的 ^_^","tags":[{"name":"心情","slug":"心情","permalink":"http://javaer.site/tags/心情/"}]},{"title":"SpringBoot与ActiveMQ的整合实践","date":"2017-02-25T09:11:36.000Z","path":"2017/02/25/SpringBoot与ActiveMQ的整合实践/","text":"这周以来，广州一直处于阴冷潮湿之中，本以为会东风送暖，春回大地，未曾想到来了一个断崖式的降温，只好把已经装箱的秋衣秋裤给重新翻了出来。好些天没有放晴了，灰色的天，淅沥的雨，肆虐的风这些场景仿佛像是去年的冬天。 这段时间为了解决接口的异步调用，学习梳理了一下消息队列（Message Queue）的一些知识，并且已经运用到产品的开发之中。下面就说说SpringBoot如何整合ActiveMQ吧。 SpringBoot1.4.1版本才将ActiveMQ的Stater集成进来，1.4.1之前的版本集成的是HornetQ和RabbitMQ，就目前流行的程度来讲RabbitMQ和Kafka是主流，从熟悉的人数来讲当之无愧的是ActiveMQ，ActiveMQ虽然有点英雄迟暮的感觉，但是因为笔者所负责开发的产品在可预见的范围之内没有性能上的压力，所以还是选择了更为熟知的ActiveMQ。 1、引入相关的Maven依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置属性文件123456789101112131415161718#activeMQ地址spring.activemq.broker-url=tcp://192.168.0.132:61616#activeMQ的用户名#spring.activemq.user=admin#activeMQ密码#spring.activemq.password=admin #是否启用内存模式（也就是不安装MQ，项目启动时同时也启动一个MQ实例）spring.activemq.in-memory=false#是否替换默认的connectionFactoryspring.activemq.pool.enabled=false#最大连接数spring.activemq.pool.maxConnections=2#超时时间spring.activemq.pool.expiryTimeout=0#空闲时间spring.activemq.pool.idleTimeout=30000#信任所有的包spring.activemq.packages.trust-all=true 3、开启JMS，生成队列123456789101112131415161718192021222324252627282930313233343536373839package site.javaer.springboot.mq.config;import javax.jms.Queue;import org.apache.activemq.command.ActiveMQQueue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jms.annotation.EnableJms;/** * * 类名称：ActiveMQConfig * 类描述： * 创建人：lzg * 创建时间：2017年2月25日 下午3:47:54 * Copyright (c)： 2017 * @version 1.0 */@Configuration@EnableJmspublic class ActiveMQConfig &#123; /** * 生成队列1 * @return */ @Bean(name=\"queue1\") public Queue queue1() &#123; return new ActiveMQQueue(\"queue1\"); &#125; /** * 生成队列2 * @return */ @Bean(name=\"queue2\") public Queue queue2() &#123; return new ActiveMQQueue(\"queue2\"); &#125;&#125; 4、MQ测试控制器1234567891011121314151617181920212223242526272829303132333435package site.javaer.springboot.mq.controller;import java.util.Map;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import site.javaer.springboot.mq.service.MQProductService;/** * * 类名称：MQController * 类描述： * 创建人：lzg * 创建时间：2017年2月25日 下午4:04:22 * Copyright (c)： 2017 * @version 1.0 */@RestControllerpublic class MQController extends BaseController&#123; @Autowired private MQProductService mqProductService; //消息生产者 @RequestMapping(\"/mq/send\") public String send(HttpServletRequest request, HttpServletResponse response) &#123; Map&lt;String, String&gt; params = super.parameter2Map(request); mqProductService.send(params); return \"send\"; &#125;&#125; 5、定义消息生产者消息生产者中定义消息发送的队列为queue1，发送的内容为一个Map对象，本次想要实现的效果是：Controller调用MQProductService方法发送一个Map对象到queue1，queue1消费者接受到内容后处理请求，如果一切正常，那么将处理后的结果转发给queue2，如果处理异常那么转发给死信队列进行处理。12345678910111213141516171819202122232425262728293031323334353637package site.javaer.springboot.mq.service;import java.util.Map;import javax.jms.Queue;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.jms.core.JmsMessagingTemplate;import org.springframework.stereotype.Service;/** * * 类名称：MQProductService * 类描述： * 创建人：lzg * 创建时间：2017年2月25日 下午3:52:24 * Copyright (c) * @version 1.0 */@Servicepublic class MQProductService &#123; @Autowired private JmsMessagingTemplate jmsMessagingTemplate; @Autowired @Qualifier(\"queue1\") private Queue queue; /** * 往消息队列中发送消息 * @param params */ public void send(Map&lt;String,String&gt; params) &#123; this.jmsMessagingTemplate.convertAndSend(this.queue, params); &#125;&#125; 6、定义消息消费者消费者类中通过继承MessageListenerAdapter实现消息队列参数的转换，经测试发现可以直接传递Map对象，本测试代码通过模拟某一个输入时认为的抛出异常来测试消息队列之间的扭转。正常情况下，Controller向队列1发送请求，队列1收到请求后进行相关的业务逻辑处理，处理完成后将处理完的返回值给queue2，接着queue2进行处理，在这过程中加入某一个环节处理失败，抛出异常，调用rollback，将消息放入死信队列中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package site.javaer.springboot.mq.service;import java.util.Map;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Session;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.jms.annotation.JmsListener;import org.springframework.jms.listener.adapter.MessageListenerAdapter;import org.springframework.jms.support.converter.MessageConversionException;import org.springframework.messaging.handler.annotation.SendTo;import org.springframework.stereotype.Service;/** * * 类名称：MQConsumeService * 类描述： * 创建人：lzg * 创建时间：2017年2月25日 下午3:52:49 * Copyright (c)： 2017 * @version 1.0 */@Servicepublic class MQConsumeService extends MessageListenerAdapter&#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); /** * queue1消费方法区 * @param message * @param session */ @JmsListener(destination = \"queue1\") @SendTo(\"queue2\") public String receiveQueue1(Message message, Session session) &#123; try &#123; Map&lt;String,String&gt; params = (Map&lt;String,String&gt;)getMessageConverter().fromMessage(message); logger.info(\"[queue1消息消费者]接收到的参数params=&#123;&#125;,message=&#123;&#125;,session=&#123;&#125;\", params, message, session); //TODO 业务逻辑具体实现，如果处理失败，那么可以主动抛出异常，此时消息将保留在此队列中 //例如：phoneNo=13925038990时抛出异常 String phoneNo = params.get(\"phoneNo\"); if(\"13925038990\".equals(phoneNo))&#123; session.rollback(); throw new JMSException(\"业务逻辑处理失败，想让消息让保留在该对队列中可以认为抛出异常！\"); &#125; return phoneNo; &#125; catch (MessageConversionException e) &#123; e.printStackTrace(); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; /** * queue2消费方法区 * @param message * @param session */ @JmsListener(destination = \"queue2\") public void receiveQueue2(Message message, Session session) &#123; try &#123; String phoneNo = (String)getMessageConverter().fromMessage(message); logger.info(\"[queue2消息消费者]接收到的参数phoneNo=&#123;&#125;,message=&#123;&#125;,session=&#123;&#125;\", phoneNo, message, session); //TODO 业务逻辑具体实现，如果处理失败，那么可以主动抛出异常，此时消息将保留在此队列中 //例如：phoneNo=13925038990时抛出异常 if(\"13925038990\".equals(phoneNo))&#123; throw new RuntimeException(\"业务逻辑处理失败，想让消息让保留在该对队列中可以认为抛出异常！\"); &#125; &#125; catch (MessageConversionException e) &#123; e.printStackTrace(); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * MQ死信队列处理 * @param message * @param session * @throws JMSException */ @JmsListener(destination = \"ActiveMQ.DLQ\") public void onMessage(Message message, Session session) throws JMSException &#123; try &#123; Map&lt;String,String&gt; params = (Map&lt;String,String&gt;)getMessageConverter().fromMessage(message); logger.info(\"[queue2消息消费者]接收到的参数params=&#123;&#125;,message=&#123;&#125;,session=&#123;&#125;\", params, message, session); //TODO 业务逻辑具体实现，如果处理失败，那么可以主动抛出异常，此时消息将保留在此队列中 //例如：phoneNo=13925038990时抛出异常 String phoneNo = params.get(\"phoneNo\"); if(\"13925038990\".equals(phoneNo))&#123; throw new RuntimeException(\"业务逻辑处理失败，想让消息让保留在该对队列中可以认为抛出异常！\"); &#125; &#125; catch (MessageConversionException e) &#123; e.printStackTrace(); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 7、测试结果1、正常情况下处理结果如下：队列1和队列2同时接收到请求，请求先在queue1中处理，处理完成后转发给queue2。 2、异常情况下的处理如下：phoneNo=13925038990时发生异常，尝试多次（默认6次）还不行，则发送到死信队列中。 8、总结总的来讲，消息队列是任何系统或者引用一个至关重要的组件，它主要有以下几个特性：1、解耦：消息队列在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。2、峰值处理能力：在访问量剧增的情况下，你的应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住增长的访问压力，而不是因为超出负荷的请求而完全崩溃。3、送达保证：消息队列提供的冗余机制保证了消息能被实际的处理，只有一个进程读取了该队列即可，并且提供了“只送达一次”保证。4、异步通信：消息队列提供了异步处理机制，允许你把一个消息放入队列，但并不立即处理它，你想向队列中放入多少消息就放多少，然后在后续的时候再去处理它们。","tags":[{"name":"Java","slug":"Java","permalink":"http://javaer.site/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://javaer.site/tags/SpringBoot/"},{"name":"MQ","slug":"MQ","permalink":"http://javaer.site/tags/MQ/"}]},{"title":"SpringBoot基于Junit的集成测试","date":"2017-02-18T12:58:06.000Z","path":"2017/02/18/SpringBoot基于Junit的集成测试/","text":"有人说，如果你不知道要去哪，往前走就是了，因为路就在脚下。但在软件开发领域，如果你没有目标，那么往往是寸步难行。开发出来的程序必是bug漫天，没人用的了。在编写应用程序的时候，明确目标最好的方式就是编写测试用例，确定程序运行过程能否达到自己的预期。 最近一直采用 SpringBoot+Maven+Thymeleaf 来开发公司的产品，SpringBoot的自动装配、起步依赖的核心特性着实让研发人员减少了各种配置，提高了开发的效率，从而更加专注于业务实现层。 默认情况下，创建 SpringBoot 模板工程，STS会遵循Maven规范同时创建出 src/main/java 和 src/test/java 两个目录。项目构建时，Maven会遵循 compile-&gt;test-&gt;package-&gt;install 的顺序依次进行，后面步骤依赖于前一步的执行结果。笔者负责的研发中，对外API、核心的组件进行了测试用例的编写。 Spring 的SpringJunit4ClassRunner可以在基于 JUnit 的应用程序测试里加载 Spring 应用程序上下文，在测试SpringBoot应用程序是，SpringBoot 除了拥有Spring的集成测试支持，它还开启自动配置和Web服务器，并提供了不少使用的测试辅助工具。下面重点讲讲 SpringJunit4ClassRunner 对 Spring 应用程序进行集成测试。 1、用SpringJunit4Class进行集成测试例如以下代码为创建 SpringBoot 工程后自动生成的测试用例，ApplicationTests添加了@RunWith、@SpringApplicationConfiguration和@WebAppConfiguration。@RunWith的参数是SpringJunit4ClassRunner.class表示开启了Spring集成测试支持。@SpringApplicationConfiguration则声明加载Spring应用程序的上下文，同时还会加载外部属性和Spring Boot日志，总的来说就是加载了完整的SpringBoot。@WebAppConfiguration注解声明，则由SpringJunit4ClassRunner创建的上下文应用是一个WebApplicationContext。 123456789101112131415161718192021222324252627package site.javaer.springboot;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.SpringApplicationConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;/** * * 类名称：ApplicationTests * 类描述： * 创建人：lzg * 创建时间：2017年2月18日 下午4:24:09 * Copyright (c)： 2017 * @version 1.0 */@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = Application.class)@WebAppConfigurationpublic class ApplicationTests &#123; @Test public void contextLoads() &#123; &#125;&#125; 除了@RunWith、@SpringApplicationConfiguration、@WebAppConfiguration这三个注解完，我们测试中可能还会用上如下一些注解：1、 @ContextConfirguration： 加载Spring应用程序上下文，但并没有加载完整的Spring Boot，只加载指定类的上下文配置。2、 @WebIntegrationTest： 不仅为测试创建上下文，还启动了一个嵌入式Servlet容器，一旦应用程序运行在嵌入式容器里，那就可以发起真实的HTTP请求，断言结果了。 2、测试web应用程序要测试一个Web应用程序，我们需要投入一些实际的HTTP请求，确认它能正确地处理那些请求，SpringBoot为我们提供了两个测试方案：1、 Spring Mock MVC：能在一个近似真实的模拟Servlet容器里测试控制器，而不用实际启动应用服务器。2、 Web集成测试：在嵌入式Servlet容器（比如Tomcat或Jetty）里启动应用程序，在真正的应用服务器里执行测试。这两种方式各有利弊。启动一个引用服务器会比模拟Servlet容器要慢一些，但基于服务器的测试会更接近于真实环境，更接近部署到生产环境运行的情况。 2.1、模拟Spring MVCSpring的Mock MVC框架模拟了Spring MVC的很多动能，它几乎和运行在Servlet容器里的应用一样，尽管实际情况并非如此。要在测试代码中创建Mock MVC，可以通过MockMvcBuilders，该类提供了两个静态方法：1、 standaloneSetup()：构建一个Mock MVC，提供一个或者多个手工创建并配置的控制器。2、 webAppContextSetup()： 使用Spring应用程序上下文来构建Mock MVC，该上下文可以包含一个或者多个配置好的控制器。主要区别在于，standaloneSetup()希望你手工初始化并注入你要测试的控制器而webAppContextSetup()则给予一个WebApplicationContext的实例，由Spring加载控制器以及依赖关系，一边进行完整的集成测试。下面举两个例子说明两者的区别：1、standaloneSetup方式测试UserController，UserController没有其他的依赖，如下代码所示:UserController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package site.javaer.springboot.controller;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import site.javaer.springboot.vo.User;/** * * 类名称：UserController * 类描述：用户信息控制层 * 创建人：lzg * 创建时间：2017年2月18日 下午5:16:07 * Copyright (c)： 2017 * @version 1.0 */@RestController@RequestMapping(\"/users\")public class UserController &#123; public static Map&lt;String, User&gt; users = Collections.synchronizedMap(new HashMap&lt;String, User&gt;()); // 创建线程安全的Map /** * 获取所有的用户列表 * @return */ @RequestMapping(value=\"/\", method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; /** * 新增用户数据 * @param user * @return */ @RequestMapping(value=\"/\", method=RequestMethod.POST) public String postUser(@ModelAttribute User user) &#123; users.put(user.getUserCode(), user); return \"success\"; &#125; /** * 通过用户编码获得用户数据 * @param userCode 用户编码 * @return */ @RequestMapping(value=\"/&#123;userCode&#125;\", method=RequestMethod.GET) public User getUser(@PathVariable String userCode) &#123; return users.get(userCode); &#125; /** * 修改用户数据 * @param userCode 用户编码 * @param user 修改后的数据 * @return */ @RequestMapping(value=\"/&#123;userCode&#125;\", method=RequestMethod.PUT) public String putUser(@PathVariable String userCode, @ModelAttribute User user) &#123; User u = users.get(userCode); u.setUserName(user.getUserName()); users.put(userCode, u); return \"success\"; &#125; /** * 根据用户编码删除某一个用户 * @param userCode 用户编码 * @return */ @RequestMapping(value=\"/&#123;userCode&#125;\", method=RequestMethod.DELETE) public String deleteUser(@PathVariable String userCode) &#123; users.remove(userCode); return \"success\"; &#125; &#125; UserControllerTests.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package site.javaer.springboot.controller;import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.SpringApplicationConfiguration;import org.springframework.mock.web.MockServletContext;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.RequestBuilder;import org.springframework.test.web.servlet.setup.MockMvcBuilders;/** * * 类名称：UserControllerTests * 类描述：用户控制测试-standaloneSetup * 创建人：lzg * 创建时间：2017年2月18日 下午5:47:05 * Copyright (c)： 2017 * @version 1.0 */@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = MockServletContext.class)@WebAppConfigurationpublic class UserControllerTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; //采用standaloneSetup方式，UserController中不能有其他的依赖，否则会报空指针异常，此种测试方式主要运用于单个方法的测试 mvc = MockMvcBuilders.standaloneSetup(new UserController()).build(); &#125; @Test public void userController() throws Exception &#123; // 1、get查一下user列表，list为空 RequestBuilder request = get(\"/users/\"); mvc.perform(request).andExpect(status().isOk()).andExpect(content().string(equalTo(\"[]\"))); // 2、post提交一个user request = post(\"/users/\").param(\"userCode\", \"1001\").param(\"userName\", \"javaer1\"); mvc.perform(request).andExpect(content().string(equalTo(\"success\"))); // 3、get获取user列表，应该有刚才插入的数据 request = get(\"/users/\"); mvc.perform(request).andExpect(status().isOk()) .andExpect(content().string(equalTo(\"[&#123;\\\"userCode\\\":\\\"1001\\\",\\\"userName\\\":\\\"javaer1\\\"&#125;]\"))); &#125; &#125; 2、webAppContextSetup方式测试UserController，UserController依赖UserService，如下代码所示:UserController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package site.javaer.springboot.controller;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import site.javaer.springboot.service.UserService;import site.javaer.springboot.vo.User;/** * * 类名称：UserController * 类描述：用户信息控制层 * 创建人：lzg * 创建时间：2017年2月18日 下午5:16:07 * Copyright (c)： 2017 * @version 1.0 */@RestController@RequestMapping(\"/users\")public class UserController &#123; @Autowired private UserService userService; /** * 获取所有的用户列表 * @return */ @RequestMapping(value=\"/\", method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; return userService.getUserList(); &#125; /** * 新增用户数据 * @param user * @return */ @RequestMapping(value=\"/\", method=RequestMethod.POST) public String postUser(@ModelAttribute User user) &#123; userService.postUser(user); return \"success\"; &#125; /** * 通过用户编码获得用户数据 * @param userCode 用户编码 * @return */ @RequestMapping(value=\"/&#123;userCode&#125;\", method=RequestMethod.GET) public User getUser(@PathVariable String userCode) &#123; return userService.getUser(userCode); &#125; /** * 修改用户数据 * @param userCode 用户编码 * @param user 修改后的数据 * @return */ @RequestMapping(value=\"/&#123;userCode&#125;\", method=RequestMethod.PUT) public String putUser(@PathVariable String userCode, @ModelAttribute User user) &#123; userService.putUser(userCode,user); return \"success\"; &#125; /** * 根据用户编码删除某一个用户 * @param userCode 用户编码 * @return */ @RequestMapping(value=\"/&#123;userCode&#125;\", method=RequestMethod.DELETE) public String deleteUser(@PathVariable String userCode) &#123; userService.remove(userCode); return \"success\"; &#125; &#125; UserService.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package site.javaer.springboot.service;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.springframework.stereotype.Service;import site.javaer.springboot.vo.User;/** * * 类名称：UserService * 类描述：用户服务层 * 创建人：lzg * 创建时间：2017年2月18日 下午7:09:23 * Copyright (c)： 2017 * @version 1.0 */@Servicepublic class UserService &#123; public static Map&lt;String, User&gt; users = Collections.synchronizedMap(new HashMap&lt;String, User&gt;()); // 创建线程安全的Map /** * 获取用户列表 * @return */ public List&lt;User&gt; getUserList() &#123; List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; /** * 新增用户 * @param user */ public void postUser(User user)&#123; users.put(user.getUserCode(), user); &#125; /** * 根据userCode获得用户对象 * @param userCode * @return */ public User getUser(String userCode)&#123; return users.get(userCode); &#125; /** * 更新用户信息 * @param userCode * @param user */ public void putUser(String userCode,User user)&#123; User u = users.get(userCode); u.setUserName(user.getUserName()); users.put(userCode, u); &#125; /** * 删除某一个用户信息 * @param userCode */ public void remove(String userCode)&#123; users.remove(userCode); &#125;&#125; UserControllerTests.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package site.javaer.springboot.controller;import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.SpringApplicationConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.RequestBuilder;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;import site.javaer.springboot.Application;/** * * 类名称：UserControllerTests * 类描述：用户控制测试-webAppContextSetup * 创建人：lzg * 创建时间：2017年2月18日 下午5:47:05 * Copyright (c)： 2017 * @version 1.0 */@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = Application.class) //此处修改为Application@WebAppConfigurationpublic class UserControllerTests &#123; private MockMvc mvc; @Autowired private WebApplicationContext webContext; //注入WebApplicationContext @Before public void setUp() throws Exception &#123; //UserController依赖UserService，mvc构建webAppContextSetup会启动SpringBoot的配置 mvc = MockMvcBuilders.webAppContextSetup(webContext).build(); &#125; @Test public void userController() throws Exception &#123; // 1、get查一下user列表，list为空 RequestBuilder request = get(\"/users/\"); mvc.perform(request).andExpect(status().isOk()).andExpect(content().string(equalTo(\"[]\"))); // 2、post提交一个user request = post(\"/users/\").param(\"userCode\", \"1001\").param(\"userName\", \"javaer1\"); mvc.perform(request).andExpect(content().string(equalTo(\"success\"))); // 3、get获取user列表，应该有刚才插入的数据 request = get(\"/users/\"); mvc.perform(request).andExpect(status().isOk()) .andExpect(content().string(equalTo(\"[&#123;\\\"userCode\\\":\\\"1001\\\",\\\"userName\\\":\\\"javaer1\\\"&#125;]\"))); &#125; &#125; 2.2、多线程测试写过Junit单元测试的同学应该会有感觉，Junit本身是不支持普通的多线程测试的，这是因为Junit的底层实现上，是用System.exit退出用例执行的。JVM都终止了，在测试线程启动的其他线程自然也无法执行。当我们碰到类似的问题的时候别人也一定碰到过该问题，google之后发现已经存在着类似的开源框架，笔者通过groboutils工具包来实现多线程的测试。在Maven仓库找了一下并没有找到相关的坐标，于是乎笔者从http://groboutils.sourceforge.net/index.html 下载下jar之后上传到自己建的Maven私服中，然后通过坐标引用。UserControllerMultiThreadedTests.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package site.javaer.springboot.controller;import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.SpringApplicationConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.RequestBuilder;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;import net.sourceforge.groboutils.junit.v1.MultiThreadedTestRunner;import net.sourceforge.groboutils.junit.v1.TestRunnable;import site.javaer.springboot.Application;/** * * 类名称：UserControllerMultiThreadedTests * 类描述：用户控制测试 * 创建人：lzg * 创建时间：2017年2月18日 下午5:47:05 * Copyright (c)： 2017 * @version 1.0 */@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = Application.class)@WebAppConfigurationpublic class UserControllerMultiThreadedTests &#123; private MockMvc mvc; @Autowired private WebApplicationContext webContext; //注入WebApplicationContext @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.webAppContextSetup(webContext).build(); &#125; @Test public void userController() throws Exception &#123; //1.Runner数组，想当于并发多少个。 TestRunnable[] trs = new TestRunnable [10]; for(int i= 0; i &lt; 10; i++)&#123; trs[i] = new UserThread(); &#125; //2.用于执行多线程测试用例的Runner，将前面定义的单个Runner组成的数组传入 MultiThreadedTestRunner mttr = new MultiThreadedTestRunner(trs); // 开发并发执行数组里定义的内容 try &#123; mttr.runTestRunnables(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; &#125; private class UserThread extends TestRunnable &#123; @Override public void runTest() throws Throwable &#123; // 1、get查一下user列表，list为空 RequestBuilder request = get(\"/users/\"); mvc.perform(request).andExpect(status().isOk()).andExpect(content().string(equalTo(\"[]\"))); // 2、post提交一个user request = post(\"/users/\").param(\"userCode\", \"1001\").param(\"userName\", \"javaer1\"); mvc.perform(request).andExpect(content().string(equalTo(\"success\"))); // 3、get获取user列表，应该有刚才插入的数据 request = get(\"/users/\"); mvc.perform(request).andExpect(status().isOk()) .andExpect(content().string(equalTo(\"[&#123;\\\"userCode\\\":\\\"1001\\\",\\\"userName\\\":\\\"javaer1\\\"&#125;]\"))); &#125; &#125; &#125; 2.3、测试运行中的应用程序@WebIntegrationTest不仅希望SpringBoot为测试创建上下文，还要启动一个嵌入式的Servlet容器，一旦应用程序运行在嵌入式容器里，你就可以发送真实的Http请求，断言结果。12345678910111213141516171819202122232425262728293031323334package site.javaer.springboot.controller;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.test.SpringApplicationConfiguration;import org.springframework.boot.test.WebIntegrationTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.web.client.RestTemplate;import site.javaer.springboot.Application;/** * * 类名称：UserControllerIntegrationTests * 创建人：lzg * 创建时间：2017年2月18日 下午8:29:29 * Copyright (c)： 2017 * @version 1.0 */@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes=Application.class)@WebIntegrationTest(randomPort=true) //随机端口测试public class UserControllerIntegrationTests &#123; //注入随机端口 @Value(\"$&#123;local.server.port&#125;\") private int port; @Test public void getUser() throws Exception &#123; RestTemplate rest = new RestTemplate(); rest.getForObject(\"http://localhost:&#123;port&#125;/users/\", String.class, port).equals(\"[]\"); &#125;&#125; 总的来说，SpringBoot与JUnit的集成测试还是非常简单、人性化的，配置的加载、依赖的注入，SpringBoot都给了很好的插件支持。","tags":[{"name":"Java","slug":"Java","permalink":"http://javaer.site/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://javaer.site/tags/SpringBoot/"},{"name":"Junit","slug":"Junit","permalink":"http://javaer.site/tags/Junit/"}]},{"title":"MySQL锁机制实践","date":"2017-02-11T07:39:07.000Z","path":"2017/02/11/MySQL锁机制实践/","text":"最近几天项目上遇到一个需求，现有系统需要访问外部的API，而API提供方的鉴权方式 ，需要三个步骤：1.访问签名接口1获取授权编码（authCode），authCode有效期10s，authCode在生命周期内无法重复获取且只能使用一次；2.根据授权编码生成加密后的数字签名；3.根据授权编码、数字签名访问接口2获得令牌token，token有效期20分钟；业务接口访问带上token值完成鉴权认证，考虑到系统采用的是集群部署，无法在应用层面保证数据的一致性，为此考虑采用MySQL的锁机制进行实现，正好系统的学习一下MySQL的锁机制。 1、MySQL锁概述相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁，目前本系统采用到的存储引擎为InnoDB。 从锁的粒度层面MySQL分为表级锁、页面锁、行级锁三种形式。三种形式在系统开销、加锁速度、是否出现死锁、并发性能、锁的粒度都不太一样，如下表格所示： 锁类型 系统开销 加锁速度 死锁 并发性能 锁的粒度 表级锁 系统开销小 加锁快 不死锁 并发底 锁的粒度大 页面锁 两者之间 两者之间 会死锁 两者之间 两者之间 行级锁 系统开销大 加锁慢 会死锁 并发高 锁的粒度小 从上述特点可见，从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web查询类应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理系统。下面重点介绍MySQL基于InnoDB的锁机制。 2、InnoDB锁机制InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。行级锁与表级锁本来就有许多不同之处，另外，事务的引入也带来了一些新问题。下面我们先介绍一点背景知识，然后详细讨论InnoDB的锁问题。 2.1、事务的ACID属性 原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。 一致性：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。 隔离性：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。 持久性：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。2.2、应用并发带来的问题 数据丢失当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更新。举个栗子：两个线程同时更改某一行数据，线程1先读取某一行数据，此时线程2也同时读取了该行数数据，线程1对该数据的某一个字段进行+1的操作，线程2也对该字段进行+1的操作，数据库将保留最后一个线程的数据，如果能做到1个线程在修改数据且没有提交事务之前，另一个线程不能访问该数据，则可避免此问题。 读脏数据一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。 不可重复读一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。 幻读一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。2.3、InnoDB行锁争用情况通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：1234567891011mysql&gt; show status like 'innodb_row_lock%';+-------------------------------+-------+| Variable_name | Value |+-------------------------------+-------+| Innodb_row_lock_current_waits | 0 || Innodb_row_lock_time | 0 || Innodb_row_lock_time_avg | 0 || Innodb_row_lock_time_max | 0 || Innodb_row_lock_waits | 0 |+-------------------------------+-------+5 rows in set (0.00 sec) 还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。具体方法如下：1234mysql&gt; use mysql;Database changedmysql&gt; CREATE TABLE innodb_monitor(a INT) ENGINE=INNODB;Query OK, 0 rows affected (0.09 sec) 然后就可以用下面的语句来进行查看：12345678910111213mysql&gt; show innodb status\\G;*************************** 1. row ***************************Status:=====================================170211 13:46:24 INNODB MONITOR OUTPUT=====================================Per second averages calculated from the last 1 seconds----------SEMAPHORES----------OS WAIT ARRAY INFO: reservation count 3, signal count 3Mutex spin waits 0, rounds 20, OS waits 0RW-shared spins 6, OS waits 3; RW-excl spins 0, OS waits 0 监视器可以通过下列命令来停止查看：12mysql&gt; DROP TABLE innodb_monitor;Query OK, 0 rows affected (0.05 sec) 设置监视器后，在SHOW INNODB STATUS的显示内容中，会有详细的当前锁等待的信息，包括表名、锁类型、锁定记录的情况等，便于进行进一步的分析和问题的确定。打开监视器以后，默认情况下每15秒会向日志中记录监控的内容，如果长时间打开会导致.err文件变得非常的巨大，所以用户在确认问题原因之后，要记得删除监控表以关闭监视器，或者通过使用“–console”选项来启动服务器以关闭写日志文件。 2.4、InnoDB的两种锁形式创建测试用到的库表：1234567891011121314151617mysql&gt; create database lock_test;Query OK, 1 row affected (0.00 sec)mysql&gt; use lock_test;Database changedmysql&gt; create table user( -&gt; user_id int comment '用户id' primary key, -&gt; user_name varchar(30) comment '用户姓名', -&gt; phone_no varchar(20) comment '用户手机号码' -&gt; );Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into user(`user_id`,`user_name`,`phone_no`) values (1, 'javaer1', '13925038990');Query OK, 1 row affected (0.00 sec)mysql&gt; insert into user(`user_id`,`user_name`,`phone_no`) values (2, 'javaer2', '13316037190');Query OK, 1 row affected (0.00 sec) 1、共享锁： 1SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE; 用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。 session1 session2 不做任何操作 不做任何操作 等待锁 不做任何操作 不做任何操作 死锁退出 获得锁后，可以成功更新 不做任何操作 2、排他锁1SELECT * FROM table_name WHERE ... FOR UPDATE session1 session2 对user_id=1的记录添加排他锁 不做任何操作 不做任何操作 能够查询数据，但是不能加排他锁，否则会挂起等待 执行更新，并且做commit 不做任何操作 不做任何操作 获得锁，执行查询语句 注意事项：InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。 3、实际应用 1、将authCode、Token存储在数据库中，作为一行记录存储； 2、每次查询数据库时加上排他锁，如果过期再去调用接口重新获取； 3、简化后的部分代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public String getToken(String logId) &#123; logger.info(\"[xxx接口调用-刷新token值]刷新token值开始，logId=&#123;&#125;\", logId); String token = \"\"; DataSource ds = getJdbc().getDataSource(); PreparedStatement pst = null; ResultSet rs = null; Connection conn = null; String querySql = \"select t.*,TIMESTAMPDIFF(SECOND, '1970-01-01 00:00:00', t.TOKEN_EXPIRE_TIME) AS TOKEN_EXPIRE_TIME_SECOND, TIMESTAMPDIFF(SECOND, '1970-01-01 00:00:00', now()) AS NOW_SECOND from xxx as t where t.ID='1' for update\"; try&#123; conn = ds.getConnection(); conn.setAutoCommit(false); pst = conn.prepareStatement(querySql); rs = pst.executeQuery(querySql); if(null != rs &amp;&amp; rs.next())&#123; //1.判断token是否过期 boolean isExpire = true; int tokenExpireTimeSecond = rs.getInt(\"TOKEN_EXPIRE_TIME_SECOND\"); int nowSecond = rs.getInt(\"NOW_SECOND\"); //2.token过期时间、当前时间 if((tokenExpireTimeSecond - nowSecond - 60) &gt; 0 )&#123; isExpire = false; token = rs.getString(\"TOKEN_DATA\"); return token; &#125; //TODO 3.获取authMap和tokenMap Map&lt;String,Object&gt; tokenMap = new HashMap&lt;String,Object&gt;(); Map&lt;String,Object&gt; authCodeMap = new HashMap&lt;String,Object&gt;(); token = (String)tokenMap.get(\"tokenData\"); if(isExpire)&#123; String updateSql = \"update xx set PUBLIC_KEY=? where ID = 1\"; pst = conn.prepareStatement(updateSql); pst.setString(1, CommonUtil.nullToString(authCodeMap.get(\"publicKey\"))); //PUBLIC_KEY pst.executeUpdate(); &#125; &#125;else&#123; //TODO 调用接口获取authCode和token数据信息，然后做新增插入操作 StringBuffer insertSql = new StringBuffer(\"insert into xxx (xx,xxx) values (?,?)\"); pst = conn.prepareStatement(insertSql.toString()); pst.setString(1, \"1\"); //ID pst.setString(2, \"xxx\"); //PUBLIC_KEY pst.executeUpdate(); &#125; conn.commit(); &#125;catch(Exception e)&#123; token = \"\"; try &#123; if(null != conn)&#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; logger.error(\"[xxx接口调用-刷新token值]出现异常，logId=&#123;&#125;，trace=\"+e, logId); &#125; finally&#123; try &#123; if(null != rs)&#123; rs.close(); &#125; if(null != pst)&#123; pst.close(); &#125; if(null != conn)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return token;&#125; 周末闲来无事，Mark一下，也算学习的笔记啦。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://javaer.site/tags/MySQL/"},{"name":"Java","slug":"Java","permalink":"http://javaer.site/tags/Java/"}]},{"title":"新年","date":"2017-01-27T09:22:25.000Z","path":"2017/01/27/新年/","text":"旧历的年底毕竟最像年底，村镇上不必说，就在天空中也显出将到新年的气象来。灰白色的沉重的晚云中间时时发出闪光，接着一声钝响，是送灶的爆竹；近处燃放的可就更强烈了，震耳的大音还没有息，空气里已经散满了幽微的火药香。《祝福》-鲁迅 93年前鲁镇过年场景大致也与我们这边的习俗也类似吧？！天空中烟花声、爆竹声此起彼伏，夹杂着远处、近处的回声，一层一层的萦绕在耳边。 爆竹声中一岁除，春风送暖入屠苏。是的，过完年也就意味着长了一岁，从年龄上来说自己真的老大不小了，但是就心理年龄而言，内心其实是个大男孩。只想说是沧桑忧愁了我的脸，人家其实才二十五，^_^。 喜欢简单，或者源于个性，或许出于经历。生活的劳累苦于心，心如间，需要我们进行删繁。这一年听的歌曲始终停留在民谣，最喜欢的歌手是汪晨蕊，不需要有太多的技巧，不需要有表现力多丰富的乐器，只是静静的弹着、唱着就能够让你内心产生一次一次的共鸣。真的，有些情绪是该说给懂的人听。 新的一年暗暗的给自己几个期许，因为有你们我会一直努力，因为有你们我将更加优秀。最后，祝大家在新的一年里步步高升，幸福美满。","tags":[{"name":"心情","slug":"心情","permalink":"http://javaer.site/tags/心情/"}]},{"title":"Hello World","date":"2017-01-23T12:58:04.000Z","path":"2017/01/23/hello-world/","text":"在Google君、Github君的帮助下，在完全闲下来的状态下，折腾了两天，我的个人博客终于搭建起来了。 整个博客系统基于Hexo，而Hexo则出自台湾大学生 tommy351 之手，是一个基于 Node.js的静态博客程序，其编译上百篇文字只需要几秒。Markdown写作，Hexo生成的静态页面推送到 Github 仓库，域名与 Github pages 绑定，这样一个逼格极高适合程序猿写作方式的博客就搭建完了。Hexo这个名字我很喜欢，就连发音都像是黑客哦！ 一直纠结是否需要自己搭建一个博客系统，之前一直在Wiz笔记上写技术博客，可是从2017年1月份开始，Wiz开始收费了，免费版无法与云端进行同步。看着自己账号下边的483篇文章，思来想去还是动手自己弄一个吧，况且之前用Wiz笔记的时候也非常熟悉 Markdown 的语法了，也特别想通过这种分享方式推动着自己不断进步。我更愿意把它作为我的一个小领地，在这里可以区别于QQ空间、微博、微信朋友圈式的分享，这里我可以完全按照自己的方式去分享心情、技术和曾经踩过的坑。 既然程序猿的世界数字永远从0开始，学习永远从 Hello World 开始，那么本篇博文就以 Hello Wolrd 为题吧。","tags":[{"name":"心情","slug":"心情","permalink":"http://javaer.site/tags/心情/"},{"name":"hexo","slug":"hexo","permalink":"http://javaer.site/tags/hexo/"}]}]